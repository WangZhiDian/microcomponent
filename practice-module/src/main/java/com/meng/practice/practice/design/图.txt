一、遍历图可能遇到的问题
图的特点：

图中可能存在回路，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。怎样避免重复访问?

解决思路:设置辅助数组visited[n]，用来标记每个被访问过的顶点。初始状态visited [i]为0

顶点i被访问，改visited [i]为1，防止被多次访问。

二、图的常用遍历
1、深度优先搜索（DFS）

2、广度优先搜索（BFS）

三、深度优先遍历（DFS）
1、遍历的方法

■在访问图中某一起始顶点V后，由V出发，访问它的任一邻接顶点;

■再从出发，访问与邻接但还未被访问过的顶点;

■然后再从出发，进行类似的访问，......

■如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止。

■接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。

■如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问;

■如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。

连通图的深度优先遍历类似于树的先根遍历

2、邻接矩阵表示的无向图深度优先遍历的实现如下图所示：



 3、算法描述

void DFS(AMGraph G, int v){          //图G为邻接矩阵类型

cout<<V; visited[v] = true;  //访问第v个顶点，visited[v]是铺助数组，用于记录图中的结点是否访问过

for(w = 0; W< G.vexnum; W++)         //依次检查邻接矩阵v所在的行

if((G.arcs[v][w]!=0) && (!visited[w]))

DFS(G,w);                //w是v的邻接点，如果w未访问，则递归调用DFS

}
四、广度优先遍历（BFS）
1、方法:从图的某一结点出发， 首先依次访问该结点的所有邻点, ,...,再按这些顶点被访问的先后次序依次访问与它们相邻接的所有未被访问的顶点。重复此过程，直至所有结点都被访问为止。图的广度优先遍历和树的层次遍历相似。

2、典型例题



 3、邻接表表示的无向图广度优先遍历的实现

算法思路：借助了一个循环队列来存储要遍历的结点：如上图所示的无向图，首先访问V1结点并且将V1下的邻接点V2和V3入队，然后再访问V2结点并且将V2结点下的邻接点V4和V5，一直执行下去，直到辅助数组visited[n]全部标记为1为止访问完毕。

4、算法描述

void BFS (Graph G, int v){               //按广度优先非递归遍历连通图G
cout<<v; visited[v] = true;             //访问第v个顶点

InitQueue(Q);                          //辅助队列Q初始化，置空

EnQueue(Q v);                           //v进队

while(!QueueEmpty(Q)){                   //队列非空

DeQueue(Q,u);                           //队头元素出队并置为u

for(w = FirstAdjVex(G, u); w>=0; w = NextAdjVex(G, u, w))
//从第一条弧开始依次的去找结点，然后再找与下一条弧相连的节点。
if(!visited[w]){                       //w为u的尚未访问的邻接顶点

count<<w; visited[w] = true; EnQueue(Q w); //w进队
       }//访问每个邻接点，访问完以后将每个邻接点入队

   }//while

}//BFS


